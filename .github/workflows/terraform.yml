name: "Terraform CI/CD"

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  TF_VAR_key_pair_name: ${{ secrets.KEY_PAIR_NAME }}

jobs:
  terraform-plan:
    name: "Terraform Plan"
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        
      - name: Terraform Init
        run: terraform -chdir=terraform init
        
      - name: Terraform Validate
        run: terraform -chdir=terraform validate
        
      - name: Terraform Plan
        run: terraform -chdir=terraform plan -no-color
        continue-on-error: true

  deploy-infrastructure:
    name: "Deploy Infrastructure"
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        
      - name: Terraform Init
        run: terraform -chdir=terraform init
        
      - name: Terraform Validate
        run: terraform -chdir=terraform validate
        
      - name: Terraform Plan
        run: terraform -chdir=terraform plan -out=tfplan
        
      - name: Terraform Apply
        run: terraform -chdir=terraform apply -auto-approve tfplan

      - name: Wait for Instance Ready
        run: |
          # Retrieve Instance ID using AWS CLI by tag name
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=aero-bound_ventures" "Name=instance-state-name,Values=pending,running" \
            --query "Reservations[].Instances[].InstanceId" \
            --output text | head -n 1)
          
          if [ -z "$INSTANCE_ID" ]; then
            echo "Error: Could not find instance with tag Name=aero-bound_ventures"
            exit 1
          fi
          
          echo "Found Instance ID: $INSTANCE_ID"
          echo "Waiting for instance to be ready..."
          aws ec2 wait instance-status-ok --instance-ids $INSTANCE_ID

      - name: Get EC2 IP
        id: get_ip
        run: echo "ec2_public_ip=$(terraform -chdir=terraform output -raw ec2_public_ip)" >> $GITHUB_OUTPUT
    outputs:
      ec2_public_ip: ${{ steps.get_ip.outputs.ec2_public_ip }}

  deploy-app:
    name: "Deploy Application"
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    steps:
      - name: Deploy to EC2
        env:
          PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          HOST: ${{ needs.deploy-infrastructure.outputs.ec2_public_ip }}
          USER: ubuntu
          GH_PAT: ${{ secrets.GH_PAT }}
          CERTBOT_EMAIL: ${{ secrets.MAIL_FROM }}
          # Env vars for .env file generation
          MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
          MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
          MAIL_FROM: ${{ secrets.MAIL_FROM }}
          MAIL_PORT: ${{ secrets.MAIL_PORT }}
          MAIL_SERVER: ${{ secrets.MAIL_SERVER }}
          ACCESS_TOKEN_EXPIRE_MINUTES: ${{ secrets.ACCESS_TOKEN_EXPIRE_MINUTES }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          ALGORITHM: ${{ secrets.ALGORITHM }}
          AMADEUS_API_KEY: ${{ secrets.AMADEUS_API_KEY }}
          AMADEUS_API_SECRET: ${{ secrets.AMADEUS_API_SECRET }}
          AMADEUS_BASE_URL: ${{ secrets.AMADEUS_BASE_URL }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          PESAPAL_CONSUMER_KEY: ${{ secrets.PESAPAL_CONSUMER_KEY }}
          PESAPAL_CONSUMER_SECRET: ${{ secrets.PESAPAL_CONSUMER_SECRET }}
          PESAPAL_BASE_URL: ${{ secrets.PESAPAL_BASE_URL }}
          PESAPAL_IPN_ID: ${{ secrets.PESAPAL_IPN_ID }}
          CLOUDINARY_URL: ${{ secrets.CLOUDINARY_URL }}
          REDIS_URL: ${{ secrets.REDIS_URL }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          GOOGLE_REDIRECT_URI: ${{ secrets.GOOGLE_REDIRECT_URI }}
          CORS_ORIGINS: ${{ secrets.CORS_ORIGINS }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
          ENVIRONMENT: ${{ secrets.ENVIRONMENT }}
        run: |
          echo "$PRIVATE_KEY" > private_key && chmod 600 private_key

          # Wait for SSH to become available (can take 30-60s after instance boot)
          echo "Waiting for SSH to become available..."
          for i in $(seq 1 10); do
            if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i private_key ${USER}@${HOST} "echo 'SSH is ready'"; then
              break
            fi
            echo "Attempt $i/10 failed, retrying in 15s..."
            sleep 15
          done

          ssh -o StrictHostKeyChecking=no -i private_key ${USER}@${HOST} "
            # Set non-interactive to avoid prompts
            export DEBIAN_FRONTEND=noninteractive

            # 1. Create swap space (2GB) if not already present
            if [ ! -f /swapfile ]; then
              echo 'Creating 2GB swap file...'
              sudo fallocate -l 2G /swapfile
              sudo chmod 600 /swapfile
              sudo mkswap /swapfile
              sudo swapon /swapfile
              echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab
              echo 'Swap created successfully'
            else
              echo 'Swap already exists'
              sudo swapon /swapfile 2>/dev/null || true
            fi
            free -h

            # 2. Install Dependencies (if missing)
            if ! command -v docker &> /dev/null; then
                echo 'Docker not found. Installing...'
                sudo apt-get update -y
                sudo apt-get install -y docker.io docker-compose-v2 git
                sudo systemctl start docker
                sudo systemctl enable docker
                sudo usermod -aG docker ubuntu
            fi

            # Debug Info
            echo 'Debug: Checking permissions...'
            id
            sudo id
            sudo docker info

            # 3. Clone or Pull
            if [ -d 'aero_bound_ventures' ]; then
              echo 'Repo exists, pulling...'
              cd aero_bound_ventures
              git pull origin main
            else
              echo 'Repo missing, cloning...'
              git clone https://${GH_PAT}@github.com/KNehe/aero_bound_ventures.git
              cd aero_bound_ventures
            fi

            cd backend

            # 4. Generate .env file dynamically
            cat <<EOF > .env
          MAIL_USERNAME=${MAIL_USERNAME}
          MAIL_PASSWORD=${MAIL_PASSWORD}
          MAIL_FROM=${MAIL_FROM}
          MAIL_PORT=${MAIL_PORT}
          MAIL_SERVER=${MAIL_SERVER}
          ACCESS_TOKEN_EXPIRE_MINUTES=${ACCESS_TOKEN_EXPIRE_MINUTES}
          SECRET_KEY=${SECRET_KEY}
          ALGORITHM=${ALGORITHM}
          AMADEUS_API_KEY=${AMADEUS_API_KEY}
          AMADEUS_API_SECRET=${AMADEUS_API_SECRET}
          AMADEUS_BASE_URL=${AMADEUS_BASE_URL}
          DATABASE_URL=${DATABASE_URL}
          PESAPAL_CONSUMER_KEY=${PESAPAL_CONSUMER_KEY}
          PESAPAL_CONSUMER_SECRET=${PESAPAL_CONSUMER_SECRET}
          PESAPAL_BASE_URL=${PESAPAL_BASE_URL}
          PESAPAL_IPN_ID=${PESAPAL_IPN_ID}
          CLOUDINARY_URL=${CLOUDINARY_URL}
          REDIS_URL=${REDIS_URL}
          GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}
          GOOGLE_CLIENT_SECRET=${GOOGLE_CLIENT_SECRET}
          GOOGLE_REDIRECT_URI=${GOOGLE_REDIRECT_URI}
          CORS_ORIGINS=${CORS_ORIGINS}
          FRONTEND_URL=${FRONTEND_URL}
          ENVIRONMENT=${ENVIRONMENT}
          EOF

            # 5. Deploy Docker containers
            # Use 'docker compose' (v2) if available, otherwise 'docker-compose'
            if docker compose version &> /dev/null; then
              echo 'Using docker compose v2'
              sudo docker compose down
              sudo docker compose up -d --build
            else
              echo 'Using legacy docker-compose'
              sudo docker-compose down
              sudo docker-compose up -d --build
            fi

            # 6. Setup Nginx reverse proxy + SSL
            echo '--- Setting up Nginx reverse proxy ---'

            # Install Nginx and Certbot if not present
            if ! command -v nginx &> /dev/null; then
              echo 'Installing Nginx...'
              sudo apt-get update -y
              sudo apt-get install -y nginx
            fi

            if ! command -v certbot &> /dev/null; then
              echo 'Installing Certbot...'
              sudo apt-get install -y certbot python3-certbot-nginx
            fi

            # Write Nginx config for api subdomain
            sudo tee /etc/nginx/sites-available/api.aeroboundventures.com > /dev/null <<'NGINX_CONF'
          server {
              listen 80;
              server_name api.aeroboundventures.com;

              location / {
                  proxy_pass http://127.0.0.1:8000;
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
                  proxy_read_timeout 300s;
                  proxy_connect_timeout 75s;
              }
          }
          NGINX_CONF

            # Enable the site (idempotent)
            sudo ln -sf /etc/nginx/sites-available/api.aeroboundventures.com /etc/nginx/sites-enabled/
            sudo rm -f /etc/nginx/sites-enabled/default

            # Test and reload Nginx
            sudo nginx -t && sudo systemctl reload nginx
            echo 'Nginx is running on port 80'

            # Attempt SSL certificate (non-blocking â€” will fail gracefully if DNS not ready)
            echo '--- Attempting SSL certificate ---'
            sudo certbot --nginx \
              -d api.aeroboundventures.com \
              --non-interactive \
              --agree-tos \
              --email ${CERTBOT_EMAIL} \
              --cert-name aeroboundventures-api \
              --redirect \
              || echo 'WARNING: Certbot failed. DNS may not be pointing to this server yet. Nginx is still running on HTTP.'

            echo '--- Nginx setup complete ---'
            sudo systemctl status nginx --no-pager
          "

